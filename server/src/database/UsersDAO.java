package database;

import static database.DAOUtilities.initializationPreparedRequest;
import static database.DAOUtilities.silentClosures;

import java.sql.*;
import java.util.ArrayList;
import java.util.logging.Logger;

import models.databaseModels.User;
import utils.Hasher;
import utils.Log;
import utils.TokenCreator;
import constants.Database;

/**
 * Implementation of a DAO to get and set information to the database's Users table.
 */
public class UsersDAO {
    private static final Logger logger = Log.getLogger(UsersDAO.class);

    private DAOFactory daoFactory;
    private TokenCreator tokenCreator;

    /**
     * Constructs a DAO for the database's Users table with a given DAOFactory.
     * @param daoFactory the main DAOFactory
     */
    UsersDAO(DAOFactory daoFactory) {
        this.daoFactory = daoFactory;
        this.tokenCreator = new TokenCreator();
    }


    /**
     * Creates a given User into the database's Users table.
     * @param user The user to create
     * @return A boolean, false if no error happened during the User's creation in the database.
     */
    public boolean create(User user){
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet autoGeneratedValues = null;
        boolean error = false;
        String token = this.tokenCreator.newToken();
        try {
            connection = daoFactory.getConnection();
            preparedStatement = initializationPreparedRequest( connection, Database.SQL_INSERT_USER, true,
                                                               user.getFirstName(), user.getLastName(),
                                                               user.getUsername(), user.getEmail(), token
                                                             );
            int statut = preparedStatement.executeUpdate();
            if ( statut == 0 ) {
                logger.severe("Failed to create a user, no new line added to the table.");
            }
            autoGeneratedValues = preparedStatement.getGeneratedKeys();
            if ( autoGeneratedValues.next() ) {
                user.setId( autoGeneratedValues.getInt( 1 ) );
            }
            else {
               logger.severe("Failed to create a user, no auto-generated ID returned." );
            }
        }
        catch (SQLIntegrityConstraintViolationException e){
            logger.warning("Failed to create a user, username or email already exists\n");
            error = true;
        }
        catch ( SQLException e ) {
            logger.severe(e.getClass().getName() + ": " + e.getMessage());
        }
        finally {
            silentClosures( autoGeneratedValues, preparedStatement, connection );
        }
        return error;
    }

    /**
     * Edits a given User in the database's Users table.
     * @param data The user's new data
     * @return A boolean, false if no error happened during the User's edition in the database.
     */
    public String edit(ArrayList<String> data, String originalUserName, String originalEmail) {
        String flag;
        int statut = DAOUtilities.executeUpdate(daoFactory, Database.SQL_EDIT_USER, data.get(0), data.get(1), data.get(2), data.get(3), originalUserName);
        if ( statut == 0 ) {
            return "Error";
        }
        if (!originalEmail.equals(data.get(3))) {
            flag = disableUser(data.get(2));
            return flag;
        }
        return "OK";
    }

    /**
     * Returns a new object User with information from the database regarding the given username.
     * @param username the username to get the information in the database from.
     * @return The User object created (if username exists, null otherwise)
     */
    public User findByUsername(String username) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        User user = null;
        try {
            resultSet = DAOUtilities.executeQuery( daoFactory, connection, preparedStatement, resultSet, Database.SQL_SELECT_BY_USERNAME, username);
            if ( resultSet.next() ) {
                user = DAOUtilities.mapUser( resultSet );
            }
        } catch ( SQLException e ) {
            logger.severe(e.getClass().getName() + ": " + e.getMessage());
        } finally {
            silentClosures( resultSet, preparedStatement, connection );
        }
        return user;
    }

    /**
     * Returns a new object User with information from the database regarding the given username and password (if they match, else returns null)
     * @param username the username to get the information in the database from.
     * @param password the password to get the information in the database from.
     * @return the User object created (null if password-username don't match)
     */
    public User findByUsernameAndPassword(String username, String password) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        User user = null;
        String hash = Hasher.hash(password, username);
        try {
            resultSet = DAOUtilities.executeQuery(daoFactory, connection, preparedStatement, resultSet,  Database.SQL_MATCH_USERNAME_PASSWORD, username, hash);
            if (resultSet.next()) {
                user = findByUsername(username);
            }
        }catch (SQLException e) {
            logger.severe(e.getClass().getName() + ": " + e.getMessage());
        }finally {
            silentClosures( resultSet, preparedStatement, connection );
        }
        return user;
    }

    /**
     * Change the password of the given user in the database.
     * @param user The User of which the password must be changed
     * @param password the Password to set
     */
    public void setPasswordToUser(User user, String password) {
        String hash = Hasher.hash(password, user.getUsername());
        int statut = DAOUtilities.executeUpdate(daoFactory, Database.SQL_SET_PASSWORD_TO_USER, hash, user.getUsername());
        if ( statut == 0 ) {
            logger.severe( "Failed to update user's password" );
        }
    }

    /**
     * Returns true if the given user's account has been activated by mail.
     * @param user The User to know if its account his activated
     * @return the activation status of the User
     */
    public boolean isActivated(User user) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        Boolean activated = false;
        try {
            resultSet = DAOUtilities.executeQuery(daoFactory, connection, preparedStatement, resultSet, Database.SQL_IS_ACTIVATED, user.getUsername());
            if (resultSet.next() ) {
                activated = (resultSet.getInt("activated") == 1) ? true : false;
            }
        } catch (SQLException e ) {
            logger.severe( "Failed to get user's activated status" );
        } finally {
            silentClosures( resultSet, preparedStatement, connection );
        }
        return activated;
    }

    /**
     * Activate a given User account (with his username).
     * @param username the username of the account to activate
     */
    public void activateUser( String username ) {
        int statut = DAOUtilities.executeUpdate(daoFactory, Database.SQL_ACTIVATE_USER, username);
        if ( statut == 0 ) {
            logger.severe("Failed to activate user");
        }
    }

    /**
     * Disable a given User account (with his username). Used after the edit of an email.
     * @param username the username of the account to disable
     */
    public String disableUser(String username){
        TokenCreator tc = new TokenCreator();
        String token = tc.newToken();
        int statut = DAOUtilities.executeUpdate(daoFactory, Database.SQL_DISABLE_USER, token, username);
        if ( statut == 0 ) {
            logger.severe("Failed to disable user");
        }
        return token;
    }


    /**
     * Returns the token stored in the database for the given username's account
     * @param username the username of the account to activate
     * @return The token of the given user
     */
    public String getTokenOfUser( String username ) {
        Connection connection = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        String token = null;
        try {
            resultSet = DAOUtilities.executeQuery(daoFactory, connection, preparedStatement, resultSet, Database.SQL_GET_TOKEN_BY_USERNAME, username);
            if (resultSet.next() ) {
                token = (resultSet.getString("token"));
            }
        } catch (SQLException e ) {
            logger.severe( "Failed to retrieve user's token" );
        } finally {
            silentClosures( resultSet, preparedStatement, connection );
        }
        return token;
    }

    /**
     * Deletes a given User in the database.
     * @param user The User to delete
     */
    public void deleteUser(User user) {
        int statut = DAOUtilities.executeUpdate(daoFactory, Database.SQL_DELETE_USER, user.getUsername());
        if ( statut == 0 ) {
            logger.severe( "Failed to delete user" );
        }
    }
}
